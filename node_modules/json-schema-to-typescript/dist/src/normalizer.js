"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cli_color_1 = require("cli-color");
const lodash_1 = require("lodash");
const utils_1 = require("./utils");
const stringify = require("json-stringify-safe");
const rules = new Map();
rules.set('Destructure unary types', schema => {
    if (schema.type && Array.isArray(schema.type) && schema.type.length === 1) {
        schema.type = schema.type[0];
    }
    return schema;
});
rules.set('Add empty `required` property if none is defined', schema => {
    if (willBeInterface(schema) && !('required' in schema)) {
        schema.required = [];
    }
    return schema;
});
rules.set('Transform `required`=false to `required`=[]', schema => {
    if (willBeInterface(schema) && schema.required === false) {
        schema.required = [];
    }
    return schema;
});
// TODO: default to empty schema (as per spec) instead
rules.set('Default additionalProperties to true', schema => {
    if (willBeInterface(schema) && !('additionalProperties' in schema)) {
        schema.additionalProperties = true;
    }
    return schema;
});
rules.set('Default top level `id`', (schema, rootSchema, fileName) => {
    if (!schema.id && stringify(schema) === stringify(rootSchema)) {
        schema.id = utils_1.toSafeString(utils_1.justName(fileName));
    }
    return schema;
});
function normalize(schema, filename) {
    let _schema = lodash_1.cloneDeep(schema);
    rules.forEach((rule, key) => {
        _schema = utils_1.mapDeep(_schema, schema => rule(schema, _schema, filename));
        utils_1.log(cli_color_1.whiteBright.bgYellow('normalizer'), `Applied rule: "${key}"`);
    });
    return _schema;
}
exports.normalize = normalize;
function willBeInterface(schema) {
    return Boolean(schema.id || schema.title || schema.properties || schema.definitions);
}
//# sourceMappingURL=normalizer.js.map