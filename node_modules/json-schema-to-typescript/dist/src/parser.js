"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cli_color_1 = require("cli-color");
const lodash_1 = require("lodash");
const typeOfSchema_1 = require("./typeOfSchema");
const AST_1 = require("./types/AST");
const utils_1 = require("./utils");
function parse(schema, rootSchema = schema, keyName, processed = new Map()) {
    // If we've seen this node before, return it.
    if (processed.has(schema)) {
        return processed.get(schema);
    }
    const definitions = getDefinitions(rootSchema);
    const keyNameFromDefinition = lodash_1.findKey(definitions, _ => _ === schema);
    // Cache processed ASTs before they are actually computed, then update
    // them in place using set(). This is to avoid cycles.
    // TODO: Investigate alternative approaches (lazy-computing nodes, etc.)
    let ast = {};
    processed.set(schema, ast);
    const set = (_ast) => Object.assign(ast, _ast);
    return isSchema(schema)
        ? parseNonLiteral(schema, rootSchema, keyName, keyNameFromDefinition, set, processed)
        : parseLiteral(schema, keyName, keyNameFromDefinition, set);
}
exports.parse = parse;
function parseLiteral(schema, keyName, keyNameFromDefinition, set) {
    return set({
        keyName,
        params: schema,
        standaloneName: keyNameFromDefinition,
        type: 'LITERAL'
    });
}
function parseNonLiteral(schema, rootSchema, keyName, keyNameFromDefinition, set, processed) {
    utils_1.log(cli_color_1.whiteBright.bgBlue('parser'), schema, '<-' + typeOfSchema_1.typeOfSchema(schema), processed.has(schema) ? '(FROM CACHE)' : '');
    switch (typeOfSchema_1.typeOfSchema(schema)) {
        case 'ALL_OF':
            return set({
                comment: schema.description,
                keyName,
                params: schema.allOf.map(_ => parse(_, rootSchema, undefined, processed)),
                standaloneName: schema.title || keyNameFromDefinition,
                type: 'INTERSECTION'
            });
        case 'ANY':
            return set({
                comment: schema.description,
                keyName,
                standaloneName: schema.title || keyNameFromDefinition,
                type: 'ANY'
            });
        case 'ANY_OF':
            return set({
                comment: schema.description,
                keyName,
                params: schema.anyOf.map(_ => parse(_, rootSchema, undefined, processed)),
                standaloneName: schema.title || keyNameFromDefinition,
                type: 'UNION'
            });
        case 'BOOLEAN':
            return set({
                comment: schema.description,
                keyName,
                standaloneName: schema.title || keyNameFromDefinition,
                type: 'BOOLEAN'
            });
        case 'NAMED_ENUM':
            return set({
                comment: schema.description,
                keyName,
                params: schema.enum.map((_, n) => ({
                    ast: parse(_, rootSchema, undefined, processed),
                    keyName: schema.tsEnumNames[n]
                })),
                standaloneName: keyName,
                type: 'ENUM'
            });
        case 'NAMED_SCHEMA':
            return set({
                comment: schema.description,
                keyName,
                params: parseSchema(schema, rootSchema, processed),
                standaloneName: computeSchemaName(schema),
                type: 'INTERFACE'
            });
        case 'NULL':
            return set({
                comment: schema.description,
                keyName,
                standaloneName: schema.title || keyNameFromDefinition,
                type: 'NULL'
            });
        case 'NUMBER':
            return set({
                comment: schema.description,
                keyName,
                standaloneName: schema.title || keyNameFromDefinition,
                type: 'NUMBER'
            });
        case 'OBJECT':
            return set({
                comment: schema.description,
                keyName,
                standaloneName: schema.title || keyNameFromDefinition,
                type: 'OBJECT'
            });
        case 'ONE_OF':
            return set({
                comment: schema.description,
                keyName,
                params: schema.oneOf.map(_ => parse(_, rootSchema, undefined, processed)),
                standaloneName: schema.title || keyNameFromDefinition,
                type: 'UNION'
            });
        case 'REFERENCE':
            throw utils_1.error('Refs should have been resolved by the resolver!', schema);
        case 'STRING':
            return set({
                comment: schema.description,
                keyName,
                standaloneName: schema.title || keyNameFromDefinition,
                type: 'STRING'
            });
        case 'TYPED_ARRAY':
            if (Array.isArray(schema.items)) {
                return set({
                    comment: schema.description,
                    keyName,
                    params: schema.items.map(_ => parse(_, rootSchema, undefined, processed)),
                    standaloneName: schema.title || keyNameFromDefinition,
                    type: 'TUPLE'
                });
            }
            else {
                return set({
                    comment: schema.description,
                    keyName,
                    params: parse(schema.items, rootSchema, undefined, processed),
                    standaloneName: schema.title || keyNameFromDefinition,
                    type: 'ARRAY'
                });
            }
        case 'UNION':
            return set({
                comment: schema.description,
                keyName,
                params: schema.type.map(_ => parse({ required: [], type: _ }, rootSchema, undefined, processed)),
                standaloneName: schema.title || keyNameFromDefinition,
                type: 'UNION'
            });
        case 'UNNAMED_ENUM':
            return set({
                comment: schema.description,
                keyName,
                params: schema.enum.map(_ => parse(_, rootSchema, undefined, processed)),
                standaloneName: schema.title || keyNameFromDefinition,
                type: 'UNION'
            });
        case 'UNNAMED_SCHEMA':
            return set({
                comment: schema.description,
                keyName,
                params: parseSchema(schema, rootSchema, processed),
                standaloneName: computeSchemaName(schema)
                    || keyNameFromDefinition,
                type: 'INTERFACE'
            });
        case 'UNTYPED_ARRAY':
            return set({
                comment: schema.description,
                keyName,
                params: AST_1.T_ANY,
                standaloneName: schema.title || keyNameFromDefinition,
                type: 'ARRAY'
            });
    }
}
/**
 * Compute a schema name using a series of fallbacks
 */
function computeSchemaName(schema) {
    return schema.title || schema.id;
}
/**
 * Helper to parse schema properties into params on the parent schema's type
 */
function parseSchema(schema, rootSchema, processed) {
    const asts = lodash_1.map(schema.properties, (value, key) => ({
        ast: parse(value, rootSchema, key, processed),
        isRequired: (schema.required || []).includes(key),
        keyName: key
    }));
    // handle additionalProperties
    switch (schema.additionalProperties) {
        case undefined:
        case true:
            return asts.concat({
                ast: AST_1.T_ANY_ADDITIONAL_PROPERTIES,
                isRequired: true,
                keyName: '[k: string]'
            });
        case false:
            return asts;
        // pass "true" as the last param because in TS, properties
        // defined via index signatures are already optional
        default:
            return asts.concat({
                ast: parse(schema.additionalProperties, rootSchema, '[k: string]', processed),
                isRequired: true,
                keyName: '[k: string]'
            });
    }
}
/**
 * TODO: Memoize
 */
function getDefinitions(schema, processed = new Set()) {
    if (processed.has(schema)) {
        return {};
    }
    processed.add(schema);
    if (Array.isArray(schema)) {
        return schema.reduce((prev, cur) => (Object.assign({}, prev, getDefinitions(cur, processed))), {});
    }
    if (lodash_1.isPlainObject(schema)) {
        return Object.assign({}, (hasDefinitions(schema) ? schema.definitions : {}), Object.keys(schema).reduce((prev, cur) => (Object.assign({}, prev, getDefinitions(schema[cur], processed))), {}));
    }
    return {};
}
/**
 * TODO: Reduce rate of false positives
 */
function hasDefinitions(schema) {
    return lodash_1.isPlainObject(schema)
        && 'definitions' in schema
        && Object.keys(schema.definitions).every(_ => lodash_1.isPlainObject(schema.definitions[_]));
}
function isSchema(schema) {
    return lodash_1.isPlainObject(schema);
}
//# sourceMappingURL=parser.js.map